# environment: deployment environment (dev | staging | prod)
environment: dev

meta:
  name: Meltica Gateway
  version: v1

runtime:
  # eventbus: in-memory event bus sizing
  eventbus:
    buffer_size: 8192
    fanout_workers: 8

  # pools: object pool capacities
  pools:
    event:
      size: 8192
      wait_queue_size: 8192
    order_request:
      size: 4096
      wait_queue_size: 4096

  risk:
    max_position_size: "250"
    max_notional_value: "50000"
    notional_currency: "USDT"
    order_throttle: 5
    order_burst: 3
    max_concurrent_orders: 6
    price_band_percent: 1.0
    allowed_order_types:
      - Limit
      - Market
    kill_switch_enabled: true
    max_risk_breaches: 3
    circuit_breaker:
      enabled: true
      threshold: 4
      cooldown: 90s

  # api_server: control API bind address (host:port or :port)
  api_server:
    addr: ":8880"

  # telemetry: OTLP exporter configuration
  telemetry:
    otlp_endpoint: http://capy.lan:4318
    service_name: meltica-gateway
    otlp_insecure: true
    enable_metrics: true

providers:
  # Real exchange wiring example; inject credentials via environment or config secrets.
  binance-spot:
    adapter:
      identifier: binance
      config:
        # api_key: "${BINANCE_API_KEY}"
        # api_secret: "${BINANCE_API_SECRET}"
        snapshot_depth: 1000
        http_timeout: 10s
        instrument_refresh_interval: 30m
        recv_window: 5s
        user_stream_keepalive: 15m

# lambda_manifest: inline lambda definitions that will be materialised at startup
# lambda_manifest:
#   lambdas:
#     - id: latency-probe-btc
#       scope:
#         binance-spot:
#           symbols:
#             - BTC-USDT
#       strategy:
#         identifier: logging
#         config:
#           dry_run: true
#           logger_prefix: "[LatencyProbe] "
#       auto_start: true
